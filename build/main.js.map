{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["'use strict';\n/*\n * Created with @iobroker/create-adapter v2.6.5\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\n// Load your modules here, e.g.:\nimport * as utils from '@iobroker/adapter-core';\nimport { getComponents, getMeasurements, getMeasurementsComp, getStations } from './lib/api_calls';\n\nclass Airquality extends utils.Adapter {\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tname: 'airquality',\n\t\t\tuseFormatDate: true,\n\t\t});\n\t\tthis.on('ready', this.onReady.bind(this));\n\t\tthis.on('unload', this.onUnload.bind(this));\n\t}\n\tstationList: Stations = {};\n\tcomponents: Components = {};\n\tprivate numberOfElements: number = 0;\n\tprivate retryCount: number = 0;\n\tprivate readonly retryDelay: number = 2;\n\tprivate readonly maxRetries: number = 3;\n\t/**\n\t * Is called when databases are connected and adapter received configuration.\n\t */\n\tprivate async onReady(): Promise<void> {\n\t\t//\n\t\tawait this.delay(Math.floor(Math.random() * 10000)); // delay start for 0-10 seconds\n\t\t//\n\t\ttry {\n\t\t\tthis.stationList = await getStations();\n\t\t\t//cons ole.log(this.stationList[931].city); //> 'Lingen'\n\t\t} catch (err) {\n\t\t\tconsole.error('[onReady:Stations] Error when calling getStations: ', err);\n\t\t\t//this.log.warn(`[onReady:Stations] Error when calling getStations: ${err}`); //??\n\t\t}\n\t\t//\n\t\ttry {\n\t\t\tthis.components = await getComponents();\n\t\t\t//cons ole.log(this.components[6].desc); //> 'Blei im Feinstaub'\n\t\t} catch (err) {\n\t\t\tconsole.error('[onReady:components] Error when calling getComponents: ', err);\n\t\t}\n\t\t//\n\t\tif (this.config.stations.length == 0) {\n\t\t\tthis.log.info('[onReady] No stations specified');\n\t\t\t// if no station is selected in config\n\t\t\tconst home: Home = this.getLocation();\n\t\t\tif (home.lat > 0) {\n\t\t\t\tconst nearestStationIdx: number = this.findNearestStation(home, this.stationList);\n\t\t\t\tthis.log.info(`[onReady] nearest Station Index: ${nearestStationIdx}`);\n\t\t\t\tawait this.writeStationToConfig(this.stationList[nearestStationIdx].code);\n\t\t\t}\n\t\t}\n\t\t//\n\t\tawait this.controller();\n\t\t//End onReady\n\t}\n\n\t/**\n\t * controller\n\t */\n\tprivate async controller(): Promise<void> {\n\t\ttry {\n\t\t\tconst data = await this.worker();\n\t\t\tif (data) {\n\t\t\t\tthis.log.info('[controller] Data retrieved successfully.');\n\t\t\t\t// Verarbeitung der Daten hier...\n\t\t\t\tawait this.setState('info.lastUpdate', { val: Date.now(), ack: true });\n\t\t\t\tthis.stopAdapter();\n\t\t\t} else {\n\t\t\t\tthrow new Error('No data received.');\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.retryCount++;\n\t\t\tthis.log.warn(`\n\t\t\t\t[controller] Retrieval failed (attempt ${this.retryCount}/${this.maxRetries}): ${String(err)}`);\n\t\t\tif (this.retryCount < this.maxRetries) {\n\t\t\t\tthis.log.info(`[controller] New attempt in ${this.retryDelay} minutes...`);\n\t\t\t\tsetTimeout(() => this.controller(), this.retryDelay * 60000);\n\t\t\t} else {\n\t\t\t\tthis.log.error('[controller] Maximum number of attempts reached. Adapter will terminated.');\n\t\t\t\tthis.stopAdapter();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * worker function to call data from the selected stations\n\t */\n\tasync worker(): Promise<boolean> {\n\t\tconst selectedStations = this.config.stations;\n\t\tthis.log.info(`[worker] Attempting to call data from the selected stations: ${selectedStations}`);\n\t\t//\n\t\tlet success = false;\n\t\ttry {\n\t\t\tfor (const station of selectedStations) {\n\t\t\t\tawait this.delay(Math.floor(Math.random() * 1000));\n\t\t\t\tthis.log.debug(`[worker] fetches data from ${station}`);\n\t\t\t\t//this.actualStation = station;\n\t\t\t\tthis.numberOfElements = 0;\n\t\t\t\t// all available components\n\t\t\t\tconst measurement = await getMeasurements(station);\n\t\t\t\tif (measurement.success) {\n\t\t\t\t\tawait this.parseData(measurement);\n\t\t\t\t\tsuccess = measurement.success;\n\t\t\t\t}\n\t\t\t\t// only specified component\n\t\t\t\tconst measurementComp = await getMeasurementsComp(station, 2);\n\t\t\t\tif (measurementComp.success) {\n\t\t\t\t\tawait this.parseData(measurementComp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\treturn success;\n\t\t} catch (error: unknown) {\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthis.log.error(`[worker] Error: ${error.message}`);\n\t\t\t} else {\n\t\t\t\tthis.log.error(`[worker] Unknown error: ${JSON.stringify(error)}`);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Persist the measurements\n\t *\n\t * @param station Station Code\n\t * @param sensor Sensor\n\t * @param name Description\n\t * @param value Value\n\t * @param unit Unit\n\t * @param role Role\n\t */\n\tasync persistData(\n\t\tstation: string,\n\t\tsensor: string,\n\t\tname: string,\n\t\tvalue: number | string,\n\t\tunit: string,\n\t\trole: string,\n\t): Promise<void> {\n\t\tconst dp_Sensor = `${this.removeInvalidCharacters(station)}.${this.removeInvalidCharacters(sensor)}`;\n\t\tthis.log.silly(\n\t\t\t`[persistData] Station \"${station}\"  Sensor \"${sensor}\"  Desc \"${name}\" with value: \"${value}\" and unit \"${unit}\" as role \"${role}\"`,\n\t\t);\n\t\t//\n\t\tif (isNumber(value)) {\n\t\t\t//value = parseFloat(value);\n\t\t\tawait this.setObjectNotExistsAsync(dp_Sensor, {\n\t\t\t\ttype: 'state',\n\t\t\t\tcommon: {\n\t\t\t\t\tname: name,\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\trole: role,\n\t\t\t\t\tunit: unit,\n\t\t\t\t\tread: true,\n\t\t\t\t\twrite: false,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\t\t} else {\n\t\t\t// or <string>\n\t\t\tawait this.setObjectNotExistsAsync(dp_Sensor, {\n\t\t\t\ttype: 'state',\n\t\t\t\tcommon: {\n\t\t\t\t\tname: name,\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\trole: role,\n\t\t\t\t\tunit: unit,\n\t\t\t\t\tread: true,\n\t\t\t\t\twrite: false,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\t\t}\n\t\t//\n\t\tawait this.setState(dp_Sensor, { val: value, ack: true, q: 0x00 });\n\t\t//\n\t\tfunction isNumber(n: any): boolean {\n\t\t\treturn !isNaN(parseFloat(n)) && !isNaN(n - 0);\n\t\t}\n\t}\n\n\t/**\n\t *\tStore metadata for the station\n\t *\n\t * @param station Station Code\n\t * @param valueNMT Number of measurement types\n\t * @param valueTLM Time of the last measurement\n\t */\n\tasync storeData(station: string, valueNMT: number | string, valueTLM: number | string): Promise<void> {\n\t\tconst dp_Station = this.removeInvalidCharacters(station);\n\t\t// Store Number of measurement types\n\t\tconst dp_SensorNMT = `${dp_Station}._NMT`;\n\t\tthis.log.silly(`[storeData] Station \"${station}\", Sensor \"_NMT\" with value: \"${valueNMT}\"`);\n\t\t//\n\t\tawait this.setObjectNotExistsAsync(dp_SensorNMT, {\n\t\t\ttype: 'state',\n\t\t\tcommon: {\n\t\t\t\tname: {\n\t\t\t\t\ten: 'Number of measurement types',\n\t\t\t\t\tde: 'Anzahl der Messarten',\n\t\t\t\t\tru: '\u0427\u0438\u0441\u043B\u043E \u0442\u0438\u043F\u043E\u0432 \u0438\u0437\u043C\u0435\u0440\u0435\u043D\u0438\u0439',\n\t\t\t\t\tpt: 'N\u00FAmero de tipos de medi\u00E7\u00E3o',\n\t\t\t\t\tnl: 'Aantal meettypes',\n\t\t\t\t\tfr: 'Nombre de types de mesure',\n\t\t\t\t\tit: 'Numero di tipi di misura',\n\t\t\t\t\tes: 'N\u00FAmero de tipos de medici\u00F3n',\n\t\t\t\t\tpl: 'Liczba typ\u00F3w pomiar\u00F3w',\n\t\t\t\t\tuk: '\u041A\u0456\u043B\u044C\u043A\u0456\u0441\u0442\u044C \u0442\u0438\u043F\u0456\u0432 \u0432\u0438\u043C\u0456\u0440\u044E\u0432\u0430\u043D\u043D\u044F',\n\t\t\t\t\t'zh-cn': '\u8BA1\u91CF\u7C7B\u578B\u6570\u76EE',\n\t\t\t\t},\n\t\t\t\ttype: 'number',\n\t\t\t\trole: 'value',\n\t\t\t\tunit: '',\n\t\t\t\tread: true,\n\t\t\t\twrite: false,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\t\t//\n\t\tawait this.setState(dp_SensorNMT, { val: valueNMT, ack: true, q: 0x00 });\n\t\t//\n\t\t// Store Time of the last measurement\n\t\tconst dp_SensorTLM = `${dp_Station}._TLM`;\n\t\tthis.log.silly(`[storeData] Station \"${station}\", Sensor \"_TLM\" with value: \"${valueTLM}\"`);\n\t\t//\n\t\tawait this.setObjectNotExistsAsync(dp_SensorTLM, {\n\t\t\ttype: 'state',\n\t\t\tcommon: {\n\t\t\t\tname: {\n\t\t\t\t\ten: 'Time of the last measurement',\n\t\t\t\t\tde: 'Zeit der letzten Messung',\n\t\t\t\t\tru: '\u0412\u0440\u0435\u043C\u044F \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0433\u043E \u0438\u0437\u043C\u0435\u0440\u0435\u043D\u0438\u044F',\n\t\t\t\t\tpt: 'Tempo da \u00FAltima medi\u00E7\u00E3o',\n\t\t\t\t\tnl: 'Tijd van de laatste meting',\n\t\t\t\t\tfr: 'Dur\u00E9e de la derni\u00E8re mesure',\n\t\t\t\t\tit: \"Tempo dell' ultima misura\",\n\t\t\t\t\tes: 'Tiempo de la \u00FAltima medici\u00F3n',\n\t\t\t\t\tpl: 'Czas ostatniego pomiaru',\n\t\t\t\t\tuk: '\u0427\u0430\u0441 \u043E\u0441\u0442\u0430\u043D\u043D\u044C\u043E\u0433\u043E \u0432\u0438\u043C\u0456\u0440\u044E\u0432\u0430\u043D\u043D\u044F',\n\t\t\t\t\t'zh-cn': '\u4E0A\u6B21\u6D4B\u91CF\u7684\u65F6\u95F4',\n\t\t\t\t},\n\t\t\t\ttype: 'string',\n\t\t\t\trole: 'text',\n\t\t\t\tunit: '',\n\t\t\t\tread: true,\n\t\t\t\twrite: false,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\t\t//\n\t\tawait this.setState(dp_SensorTLM, { val: valueTLM, ack: true, q: 0x00 });\n\t}\n\n\t/**\n\t * Retrieves the desired data from the payload and prepares data for storage\n\t *\n\t * @param {} payload Object from Response\n\t //* @returns Data to persist\n\t */\n\tasync parseData(payload: any): Promise<void> {\n\t\tthis.log.debug(`[parseData] Payload: ${JSON.stringify(payload)}`);\n\t\t/*\n\t\tPayload: {\"stationId\":\"145\",\"measurementTime\":\"2025-06-03 14:00:00\",\"measurementValues\":[\n\t\t[3,105,1,\"1.746\"],[5,5,0,\"0.25\"],[1,17,0,\"0.85\"],[9,10,0,\"1\"]\n\t\t]}\n  \t\t*/\n\t\tif (Object.keys(payload).length === 0) {\n\t\t\tthis.log.debug('[#parseData] Payload ist leer');\n\t\t\treturn;\n\t\t}\n\t\tconst localDate = new Date();\n\t\tconst summerOffset = localDate.getTimezoneOffset() / 60;\n\t\t//\n\t\tconst stationId: number = payload.stationId;\n\t\tconst timeEndAdjusted: string = this.correctHour(payload.measurementTime, summerOffset * -1 - 1);\n\t\t//\n\t\tfor (const item of Object.keys(payload.measurementValues)) {\n\t\t\tconst measurement = payload.measurementValues[item];\n\t\t\tawait this.persistData(\n\t\t\t\tthis.stationList[stationId].code,\n\t\t\t\tthis.components[measurement[0]].code,\n\t\t\t\tthis.components[measurement[0]].desc,\n\t\t\t\tmeasurement[1], // Value\n\t\t\t\tthis.components[measurement[0]].unit,\n\t\t\t\t'value',\n\t\t\t);\n\t\t\tthis.numberOfElements++;\n\t\t}\n\t\tif (this.numberOfElements > 0) {\n\t\t\tawait this.storeData(this.stationList[stationId].code, this.numberOfElements, timeEndAdjusted);\n\t\t}\n\t\tthis.log.debug(`[parseData] Measured values from ${this.numberOfElements} sensors determined`);\n\t\treturn;\n\t}\n\n\t/**\n\t * Use the specified coordinates from the configuration\n\t *\n\t * @returns Koordinates(lat, lon)\n\t */\n\tgetLocation(): Home {\n\t\tthis.log.debug('[getLocation] try to use the location from the system configuration');\n\t\tif (this.latitude == undefined || this.latitude == 0 || this.longitude == undefined || this.longitude == 0) {\n\t\t\tthis.log.warn(\n\t\t\t\t'longitude/latitude not set in system-config - please check instance configuration of \"System settings\"',\n\t\t\t);\n\t\t\treturn { lat: -1, lon: -1 };\n\t\t}\n\t\tthis.log.debug(`[getLocation] using Latitude: ${this.latitude} and Longitude: ${this.longitude}`);\n\t\treturn { lat: this.latitude, lon: this.longitude };\n\t}\n\n\t/**\n\t * search for the nearest station using coordinates\n\t *\n\t * @param localHome Koordinates from system\n\t * @param coordinates Koordinates from stations\n\t * @returns stationId\n\t */\n\tfindNearestStation(localHome: Home, coordinates: Stations): number {\n\t\tlet minDistance: number = Number.MAX_VALUE;\n\t\tlet nearestStation = 0;\n\t\tthis.log.debug(`[findNearestStation]: Latitude: ${localHome.lat} Longitude: ${localHome.lon}`);\n\t\t//\n\t\tfor (const key of Object.keys(coordinates)) {\n\t\t\tconst distance = this.getDistanceFromLatLonInKm(\n\t\t\t\tlocalHome.lat,\n\t\t\t\tlocalHome.lon,\n\t\t\t\tparseFloat(coordinates[key].lat),\n\t\t\t\tparseFloat(coordinates[key].lon),\n\t\t\t);\n\t\t\tif (distance < minDistance) {\n\t\t\t\tminDistance = distance;\n\t\t\t\tnearestStation = parseInt(key);\n\t\t\t}\n\t\t}\n\t\tthis.log.debug(`[findNearestStation]: >>> Station Idx: ${nearestStation}`);\n\t\treturn nearestStation;\n\t}\n\n\t/**\n\t * write code of Station in UI-config\n\t *\n\t * @param localStation code of mesurement station\n\t */\n\tasync writeStationToConfig(localStation: string): Promise<void> {\n\t\tconst _station: Array<string> = [];\n\t\tawait this.getForeignObject(`system.adapter.${this.namespace}`, (err, obj) => {\n\t\t\tif (err) {\n\t\t\t\tthis.log.error(`[writeStationToConfig] ${err}`);\n\t\t\t} else {\n\t\t\t\tif (obj) {\n\t\t\t\t\t_station.push(localStation); // must be an array\n\t\t\t\t\tobj.native.stations = _station; // modify object\n\t\t\t\t\tthis.setForeignObject(obj._id, obj, err => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tthis.log.error(`[writeStationToConfig] Error when writing in config: ${err}`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.log.debug(`[writeStationToConfig] New Station in config: ${localStation}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * calculates the distance between two coordinates using the Haversine formula\n\t *\n\t * @param lat1 Latitude of the place of residence\n\t * @param lon1 Longitude of the place of residence\n\t * @param lat2 Latitude of the station\n\t * @param lon2 Longitude of the station\n\t * @returns Distance to the station\n\t */\n\tgetDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n\t\tconst R = 6371; // Radius of the earth in kilometres\n\t\tconst dLat = deg2rad(lat2 - lat1);\n\t\tconst dLon = deg2rad(lon2 - lon1);\n\t\tconst a =\n\t\t\tMath.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\t\tMath.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\tconst d = R * c; // Distance in km\n\t\treturn d;\n\t\t// Convert to radians\n\t\tfunction deg2rad(deg: number): number {\n\t\t\treturn deg * (Math.PI / 180);\n\t\t}\n\t}\n\n\t/**\n\t * removes illegal characters\n\t *\n\t * @param inputString Designated name for an object/data point\n\t * @returns Cleaned name for an object/data point\n\t */\n\tremoveInvalidCharacters(inputString: string): string {\n\t\tconst regexPattern = '[^a-zA-Z0-9]+';\n\t\tconst regex = new RegExp(regexPattern, 'gu');\n\t\treturn inputString.replace(regex, '_');\n\t}\n\n\t/**\n\t * correct datestring from datestring by adding x hours (offset)\n\t *\n\t * @param s Datestring\n\t * @param offset Offset\n\t * @returns String with Date & Time\n\t */\n\tcorrectHour(s: string, offset: number): string {\n\t\tconst dateString = s.split(' ')[0].split('-');\n\t\tconst sDate = `${dateString[2]}.${dateString[1]}.${dateString[0]}`;\n\t\t//\n\t\tconst timeString = s.split(' ')[1].split(':');\n\t\tconst hour = parseInt(timeString[0]) + offset; //Korrektur\n\t\tconst sHour = hour.toString().padStart(2, '0');\n\t\tconst sTime = `${sHour}:${timeString[1]}`;\n\t\treturn `${sDate} ${sTime}`;\n\t}\n\t/**\n\t * my own methode to stop an adapter\n\t */\n\tprivate stopAdapter(): void {\n\t\tthis.log.silly('[stopAdapter] finished - stopping instance');\n\t\tthis.terminate ? this.terminate('Everything done. Going to terminate till next schedule', 11) : process.exit(0);\n\t\t/*\n\t\tif (typeof this.stop === 'function') {\n\t\t\tawait this.stop();\n\t\t} else {\n\t\t\tthis.log.warn(\n\t\t\t\t'this.stop ist nicht verf\u00FCgbar \u2013 Adapter konnte m\u00F6glicherweise nicht korrekt beendet werden.',\n\t\t\t);\n\t\t}\n\t\t*/\n\t}\n\n\t/**\n\t * Is called when adapter shuts down - callback has to be called under any circumstances!\n\t *\n\t * @param callback Callback\n\t */\n\tprivate onUnload(callback: () => void): void {\n\t\ttry {\n\t\t\t// Here you must clear all timeouts or intervals that may still be active\n\t\t\t//setTimeout ??\n\t\t\tcallback();\n\t\t} catch (e) {\n\t\t\tthis.log.debug(`[onUnload] ${JSON.stringify(e)}`);\n\t\t\tcallback();\n\t\t}\n\t}\n}\n\nif (require.main !== module) {\n\t// Export the constructor in compact mode\n\tmodule.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Airquality(options);\n} else {\n\t// otherwise start the instance directly\n\t(() => new Airquality())();\n}\n"],
  "mappings": "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",
  "names": ["err"]
}
